## 环形链表


## 解题思路分析

### 方法一：快慢指针
链表的题尽量往**指针**上靠，一个指针解决不了可以尝试使用两个。指针的使用也分多种情况，普通的解法不行可以考虑**两个指针的运动方式**，比如说**指针相对运动**，**指针快慢运动**。

**常见的解题思路：**
1. 两个相对运动的指针
1. 有间隔的两个指针
例如求倒数第K个节点
2. 快慢指针
例如求链表的中间元素

这道题目就是应用的**快慢指针**。设置两个指针，同时运动。快指针每次往前两步，慢指针每次往前一步。如果不存在环，快指针会率先到达链表末尾（指针为空）。如果存在环，快指针和慢指针一定会在环中的某个节点相遇。

最坏的情况是，等慢指针刚进入环中，快指针正好慢指针的上一个节点，此时两者速度差为1，则需要K（环的节点数）的时间相遇。此时的时间复杂度为**O(N+K)**。也就是**O(N)**。

**实现步骤：**

1. 参数检验，head == null || head.next() == null
2. 定义快慢指针
3. 如果快指针的下一个指针不为空，且快指针的下下个指针不为空（快指针每次移动两步），进入循环
4. 在循环体中判断快慢指针是否相等，相等则直接退出
5. 如果退出循环体，说明快指针到达链表尾，表示链表无环

### 方法二：哈希表

通过判断节点是否被访问过判断是否有环，每次访问节点都将其记录在哈希表中。

**解题思路：**
遍历链表中的节点，每次访问之后节点记录在表中。如果存在环，则一定在遍历到某个节点时，检测到表中已经存在此节点。如果不存在环，则遍历到链表尾部。

**实现步骤：**
1. 新建一个 `HashSet`，存放访问记录
2. 遍历节点
3. 判断表中是否存在输入节点，如果存在则返回 `true`，否则将当前节点添加到表中
4. 如果退出循环，表示遍历到结尾，即不存在环